import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import { usePatternFlyDocsTool } from './tool.patternFlyDocs';
import { fetchDocsTool } from './tool.fetchDocs';
import { componentSchemasTool } from './tool.componentSchemas';
import { getOptions, runWithOptions } from './options.context';
import { type GlobalOptions } from './options';
import { startHttpTransport, type HttpServerHandle } from './server.http';
import { memo } from './server.caching';

type McpTool = [string, { description: string; inputSchema: any }, (args: any) => Promise<any>];

type McpToolCreator = (options?: GlobalOptions) => McpTool;

/**
 * Server instance with shutdown capability
 */
interface ServerInstance {

  /**
   * Stop the server gracefully
   */
  stop(): Promise<void>;

  /**
   * Is the server running?
   */
  isRunning(): boolean;
}

/**
 * Internal server creation function (not memoized)
 *
 * @param options
 * @param settings
 * @param settings.tools
 * @param settings.enableSigint
 * @param settings.allowProcessExit
 */
const _runServerInternal = async (options = getOptions(), {
  tools = [
    usePatternFlyDocsTool,
    fetchDocsTool,
    componentSchemasTool
  ],
  enableSigint = true,
  allowProcessExit = true
}: { tools?: McpToolCreator[]; enableSigint?: boolean, allowProcessExit?: boolean } = {}): Promise<ServerInstance> => {
  let server: McpServer | null = null;
  let transport: StdioServerTransport | null = null;
  let httpHandle: HttpServerHandle | null = null;
  let running = false;

  const stopServer = async () => {
    if (server && running) {
      if (httpHandle) {
        await httpHandle.close();
        httpHandle = null;
      }

      await server?.close();
      running = false;
      console.log(`${options.name} server stopped`);

      if (allowProcessExit) {
        process.exit(0);
      }
    }
  };

  try {
    server = new McpServer(
      {
        name: options.name,
        version: options.version
      },
      {
        capabilities: {
          tools: {}
        }
      }
    );

    tools.forEach(toolCreator => {
      const [name, schema, callback] = toolCreator(options);

      console.info(`Registered tool: ${name}`);
      server?.registerTool(name, schema, (args = {}) => runWithOptions(options, async () => await callback(args)));
    });

    if (enableSigint) {
      process.on('SIGINT', async () => stopServer());
    }

    if (options.http) {
      httpHandle = await startHttpTransport(server, options);
      // HTTP transport logs its own message
    } else {
      transport = new StdioServerTransport();

      await server.connect(transport);
      // STDIO log
      console.log(`${options.name} server running on stdio`);
    }

    running = true;
  } catch (error) {
    console.error(`Error creating ${options.name} server:`, error);
    throw error;
  }

  return {
    async stop(): Promise<void> {
      return await stopServer();
    },

    isRunning(): boolean {
      return running;
    }
  };
};

/**
 * Server creation function
 *
 * @param options - Server options
 * @param settings - Server settings (tools, signal handling, etc.)
 * @returns Server instance
 */
const runServer = _runServerInternal as typeof _runServerInternal & {

  /**
   * Memoized server creation function
   * Prevents port conflicts by returning the same server instance for identical configurations.
   * Automatically cleans up servers when cache expires.
   */
  memo: typeof _runServerInternal;
};

/**
 * Memoized server creation function
 * Prevents port conflicts by returning the same server instance for identical configurations.
 * Automatically cleans up servers when cache expires.
 */
runServer.memo = memo(
  _runServerInternal,
  {
    cacheLimit: 10,
    onCacheExpire: async entries => {
      // Handle cache expiration - close all servers
      for (const { value } of entries) {
        // value is Promise<ServerInstance> (cached promise)
        try {
          const serverInstance = await Promise.resolve(value);

          if (serverInstance.isRunning()) {
            await serverInstance.stop();
          }
        } catch {
          // Server creation failed or already stopped
          // Ignore - server is already closed or never started
        }
      }
    }
  }
);

export {
  runServer,
  _runServerInternal, // Exported for test mocking
  type McpTool,
  type McpToolCreator,
  type ServerInstance
};
